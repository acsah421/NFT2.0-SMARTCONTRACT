/**
 * SPDX-License-Identifier: MIT
 * @author Accubits
 * @title NFTMarketplaceERC721
 */

pragma solidity 0.8.13;

import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

/**
 * @title NFT2.0 MarketPlace ERC721 Contract
 * @dev {ERC721} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 */
contract NFTMarketplaceERC721 is
    Initializable,
    AccessControlEnumerableUpgradeable,
    OwnableUpgradeable,
    ERC721EnumerableUpgradeable,
    ERC721BurnableUpgradeable,
    ERC721PausableUpgradeable
{
    using StringsUpgradeable for uint256;

    mapping(uint256 => string) private _tokenURIs;
    string public _contractURI;

    struct Royalties {
        address account;
        uint256 percentage;
    }

    /// storing the royalty details of a token
    mapping(uint256 => Royalties) private _royalties;

    event RoyaltyAdded(
        uint256 indexed tokenId,
        address indexed account,
        uint256 percentage
    );

    /**
     * @dev Constructor/Initilizer
     * @param name ERC721 Token name
     * @param symbol ERC721 Token symbol
     * @param baseTokenURI ERC721 Token Base URI
     * @param rootAdmin Admin Address
     */
    function initialize(
        string memory name,
        string memory symbol,
        string memory baseTokenURI,
        address rootAdmin
    ) public virtual initializer {
        __NFTMarketplaceUpgradableV2_init(
            name,
            symbol,
            baseTokenURI,
            rootAdmin
        );
    }

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    string private _baseTokenURI;

    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     * @param name ERC721 Token name
     * @param symbol ERC721 Token symbol
     * @param baseTokenURI ERC721 Token Base URI
     * @param rootAdmin Admin Address
     */
    function __NFTMarketplaceUpgradableV2_init(
        string memory name,
        string memory symbol,
        string memory baseTokenURI,
        address rootAdmin
    ) internal onlyInitializing {
        __Context_init_unchained();
        __ERC165_init_unchained();
        __AccessControl_init_unchained();
        __AccessControlEnumerable_init_unchained();
        __ERC721_init_unchained(name, symbol);
        __ERC721Enumerable_init_unchained();
        __Ownable_init_unchained();
        __ERC721Burnable_init_unchained();
        __Pausable_init_unchained();
        __ERC721Pausable_init_unchained();
        __NFTMarketplaceUpgradableV2_init_unchained(baseTokenURI, rootAdmin);
    }

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     * @param baseTokenURI ERC721 Token Base URI
     * @param rootAdmin Admin Address
     */
    function __NFTMarketplaceUpgradableV2_init_unchained(
        string memory baseTokenURI,
        address rootAdmin
    ) internal onlyInitializing {
        _baseTokenURI = baseTokenURI;

    royaltyAmount = (_salePrice * _royalties[_tokenId].percentage) / 10000;
    receiver = _royalties[_tokenId].account;
  }

  /**
   * @dev This funtion is to give authority to root admin to transfer token to the
   * buyer on behalf of the token owner
   *
   * The token owner can approve and renounce the access via this function
   */
  function setApprovalForOwner(bool approval) public {
    address defaultAdmin = getRoleMember(ADMIN_ROLE, 0);
    setApprovalForAll(defaultAdmin, approval);
  }

  /**
   * @dev This funtion is to give authority to minter to transfer token to the
   * buyer on behalf of the token owner
   *
   * The token owner can approve and renounce the access via this function
   */
  function setApprovalForMinter(bool approval, address minterAccount) public {
    require(hasRole(MINTER_ROLE, minterAccount), 'not a minter address');
    setApprovalForAll(minterAccount, approval);
  }

  /**
   * @dev This funtion is to check weather the contract admin have approval from a token owner
   *
   */
  function isApprovedForOwner(address account) public view returns (bool approval) {
    address defaultAdmin = getRoleMember(ADMIN_ROLE, 0);
    return isApprovedForAll(account, defaultAdmin);
  }

  /**
   * @dev Pauses all token transfers.
   *
   * See {ERC721Pausable} and {Pausable-_pause}.
   *
   * Requirements:
   *
   * - the caller must have the `PAUSER_ROLE`.
   */
  function pause() public virtual onlyPauser {
    _pause();
  }

  /**
   * @dev Unpauses all token transfers.
   *
   * See {ERC721Pausable} and {Pausable-_unpause}.
   *
   * Requirements:
   *
   * - the caller must have the `PAUSER_ROLE`.
   */
  function unpause() public virtual onlyPauser {
    _unpause();
  }

  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 tokenId,
    uint256 batchSize
  ) internal virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721PausableUpgradeable) {
    super._beforeTokenTransfer(from, to, tokenId, batchSize);
  }

  /**
   * @dev See {IERC165-supportsInterface}.
   */
  function supportsInterface(bytes4 interfaceId)
    public
    view
    virtual
    override(AccessControlEnumerableUpgradeable, ERC721Upgradeable, ERC721EnumerableUpgradeable)
    returns (bool)
  {
    /// add support to EIP-2981: NFT Royalty Standard
    if (interfaceId == _INTERFACE_ID_ERC2981) {
      return true;
    }

    /**
     * @dev Function to get Base URI
     * @return baseURI Base URI
     */
    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

  function _beforeConsecutiveTokenTransfer(
    address from,
    address to,
    uint256 tokenId, 
    uint96 size
  ) internal virtual {
    super._beforeTokenTransfer(from, to, tokenId, size);
  }
}
